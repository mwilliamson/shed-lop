package lop;

import sequences;
import strings;
import lazySequences;

import hat.TestCase;
import duck.assertThat;
import duck.isList;
import duck.equalTo;
import duck.anything;
import duck.MatchResult;

import lop.rules;
import lop.results.Success;
import lop.Token;
import lop.StringSource;
import lop.strings.createStringSource;
import lop.testing.isSuccess;
import lop.testing.isFailure;
import lop.testing.isFailureWithError;
import lop.testing.isErrorWithError;
import lop.Error;
import lop.results.Failure;

def source fun(value: String) => createStringSource(value, "raw string");

public val rulesTest = listOf[TestCase](
    TestCase("rules.token fails if sequence is empty", fun() =>
        assertFailedParseWithError[String](
            rules.token("identifier", "true"),
            emptyList,
            Error("token", "end of token sequence")
        )
    ),
    
    TestCase("rules.token fails if input token is of wrong type", fun() =>
        assertFailedParseWithError[String](
            rules.token("identifier", "true"),
            listOf(Token("keyword", "true", source("true"))),
            Error("identifier \"true\"", "keyword \"true\"")
        )
    ),
    
    TestCase("rules.token fails if input token has wrong value", fun() =>
        assertFailedParseWithError[String](
            rules.token("identifier", "true"),
            listOf(Token("identifier", "false", source("false"))),
            Error("identifier \"true\"", "identifier \"false\"")
        )
    ),
    
    TestCase("rules.token succeeds if type and value match", fun() =>
        assertSuccessfulParse[String](
            rules.token("identifier", "true"),
            listOf(Token("identifier", "true", source("true"))),
            equalTo[String]("true")
        )
    ),
    
    TestCase("rules.tokenOfType fails if input token is of wrong type", fun() =>
        assertFailedParseWithError[String](
            rules.tokenOfType("identifier"),
            listOf(Token("keyword", "true", source("true"))),
            Error("identifier", "keyword \"true\"")
        )
    ),
    
    TestCase("rules.tokenOfType succeeds with value of token if token type matches", fun() =>
        assertSuccessfulParse[String](
            rules.tokenOfType("keyword"),
            listOf(Token("keyword", "true", source("true"))),
            equalTo[String]("true")
        )
    ),
    
    TestCase("rules.tokenOfType succeeds with value of token if token type matches", fun() =>
        assertSuccessfulParse[String](
            rules.tokenOfType("keyword"),
            listOf(Token("keyword", "true", source("true"))),
            equalTo[String]("true")
        )
    ),
    
    TestCase("rules.firstOf returns first success", fun() =>
        assertSuccessfulParse[String](
            rules.firstOf("literal", listOf(
                rules.token("keyword", "true"),
                rules.token("keyword", "false"),
                rules.token("keyword", "unit")
            )),
            listOf(Token("keyword", "false", source("false"))),
            equalTo[String]("false")
        )
    ),
    
    TestCase("rules.firstOf fails if no sub-rules match", fun() =>
        assertFailedParseWithError[String](
            rules.firstOf("literal", listOf(
                rules.token("keyword", "true"),
                rules.token("keyword", "false")
            )),
            listOf(Token("identifier", "blah", source("blah"))),
            Error("literal", "identifier \"blah\"")
        )
    ),
    
    TestCase("rules.firstOf fatally fails if subrule fails even if following rule is success", fun() =>
        assertErrorParseWithError(
            rules.firstOf("literal", listOf(
                fatalRule,
                rules.token("keyword", "false"),
                rules.token("keyword", "unit")
            )),
            listOf(Token("keyword", "false", source("false"))),
            Error("<expected>", "<actual>")
        )
    ),
    
    TestCase("rules.map does nothing to failures", fun() =>
        assertFailedParseWithError[String](
            rules.map[Unit, Unit](failingRule),
            emptyList,
            Error("<expected>", "<actual>")
        )
    ),
    
    TestCase("rules.map maps value of success using passed function", fun() =>
        assertSuccessfulParse[String](
            rules.map[String, String](
                rules.token("identifier", "blah"),
                fun(value: String) => value.concat(value)
            ),
            listOf(Token("identifier", "blah", source("blah"))),
            equalTo[String]("blahblah")
        )
    ),
    
    TestCase("rules.sequence fails if element of sequence is missing", fun() =>
        assertFailedParseWithError[String](
            rules.sequence()
                .next(rules.token("keyword", "if"))
                .next(rules.tokenOfType("identifier"))
                .next(rules.token("keyword", "then"))
                .tuple(),
            listOf(Token("keyword", "if", source("if")), Token("keyword", "then", source("then"))),
            Error("identifier", "keyword \"then\"")
        )
    ),
    
    TestCase("rules.sequence succeeds if all elements match", fun() =>
        assertSuccessfulParse[String](
            rules.sequence()
                .next(rules.token("keyword", "if"))
                .next(rules.tokenOfType("identifier"))
                .next(rules.token("keyword", "then"))
                .tuple(),
            listOf(
                Token("keyword", "if", source("if")),
                Token("identifier", "go", source("go")),
                Token("keyword", "then", source("then"))
            ),
            anything
        )
    ),
    
    TestCase("rules.sequence() can capture first value", fun() =>
        assertSuccessfulParse[String](
            rules.sequence()
                .capture(rules.tokenOfType("identifier"))
                .next(rules.token("symbol", ")"))
                .tuple(),
            listOf(
                Token("identifier", "go", source("go")),
                Token("symbol", ")", source(")"))
            ),
            equalTo[String](tuple("go"))
        )
    ),
    
    TestCase("rules.sequence() can capture a single value", fun() =>
        assertSuccessfulParse(
            rules.sequence()
                .next(rules.token("symbol", "("))
                .capture(rules.tokenOfType("identifier"))
                .next(rules.token("symbol", ")"))
                .head(),
            listOf(
                Token("symbol", "(", source("(")),
                Token("identifier", "go", source("go")),
                Token("symbol", ")", source(")"))
            ),
            equalTo("go")
        )
    ),
    
    TestCase("rules.sequence() can capture a single value as a tuple", fun() =>
        assertSuccessfulParse[String](
            rules.sequence()
                .next(rules.token("symbol", "("))
                .capture(rules.tokenOfType("identifier"))
                .next(rules.token("symbol", ")"))
                .tuple(),
            listOf(
                Token("symbol", "(", source("(")),
                Token("identifier", "go", source("go")),
                Token("symbol", ")", source(")"))
            ),
            equalTo[String](tuple("go"))
        )
    ),
    
    TestCase("rules.sequence() can capture multiple values", fun() =>
        assertSuccessfulParse[String](
            rules.sequence()
                .next(rules.token("symbol", "("))
                .capture(rules.tokenOfType("identifier"))
                .next(rules.token("symbol", ","))
                .capture(rules.tokenOfType("identifier"))
                .next(rules.token("symbol", ")"))
                .tuple(),
            listOf(
                Token("symbol", "(", source("(")),
                Token("identifier", "go", source("go")),
                Token("symbol", ",", source(",")),
                Token("identifier", "away", source("away")),
                Token("symbol", ")", source(")"))
            ),
            equalTo(tuple("go", "away"))
        )
    ),
    
    TestCase("rules.sequence() can map tuple", fun() =>
        assertSuccessfulParse[String](
            rules.sequence()
                .next(rules.token("symbol", "("))
                .capture(rules.tokenOfType("identifier"))
                .next(rules.token("symbol", ","))
                .capture(rules.tokenOfType("identifier"))
                .next(rules.token("symbol", ")"))
                .map(fun(first: String, second: String) => first.concat(" ").concat(second)),
            listOf(
                Token("symbol", "(", source("(")),
                Token("identifier", "go", source("go")),
                Token("symbol", ",", source(",")),
                Token("identifier", "away", source("away")),
                Token("symbol", ")", source(")"))
            ),
            equalTo("go away")
        )
    ),
    
    TestCase("rules.sequence() returns error if missing element after cut", fun() =>
        assertErrorParseWithError[String](
            rules.sequence()
                .next(rules.token("keyword", "if"))
                .cut()
                .next(rules.tokenOfType("identifier"))
                .tuple(),
            listOf(Token("keyword", "if", source("if")), Token("keyword", "then", source("then"))),
            Error("identifier", "keyword \"then\"")
        )
    ),
    
    TestCase("rules.sequence() returns failure if missing element before cut", fun() =>
        assertFailedParseWithError[String](
            rules.sequence()
                .next(rules.token("keyword", "if"))
                .cut()
                .next(rules.tokenOfType("identifier"))
                .tuple(),
            listOf(Token("keyword", "then", source("then"))),
            Error("keyword \"if\"", "keyword \"then\"")
        )
    ),
    
    TestCase("zeroOrMoreWithSeparator can match no values", fun() =>
        assertSuccessfulParse(
            rules.zeroOrMoreWithSeparator(rules.tokenOfType("identifier"), rules.token("symbol", ",")),
            emptyList,
            equalTo(emptyList)
        )
    ),
    
    TestCase("zeroOrMoreWithSeparator can match one value", fun() =>
        assertSuccessfulParse(
            rules.zeroOrMoreWithSeparator(rules.tokenOfType("identifier"), rules.token("symbol", ",")),
            listOf(
                Token("identifier", "go", source("go"))
            ),
            equalTo(listOf("go"))
        )
    ),
    
    TestCase("zeroOrMoreWithSeparator can match multiple values", fun() =>
        assertSuccessfulParse(
            rules.zeroOrMoreWithSeparator(rules.tokenOfType("identifier"), rules.token("symbol", ",")),
            listOf(
                Token("identifier", "go", source("go")),
                Token("symbol", ",", source(",")),
                Token("identifier", "away", source("away"))
            ),
            equalTo(listOf("go", "away"))
        )
    ),
    
    TestCase("zeroOrMoreWithSeparator does not consume final separator", fun() =>
        assertSuccessfulParse(
            rules.sequence()
                .next(rules.zeroOrMoreWithSeparator(rules.tokenOfType("identifier"), rules.token("symbol", ",")))
                .next(rules.token("symbol", ","))
                .tuple(),
            listOf(
                Token("identifier", "go", source("go")),
                Token("symbol", ",", source(","))
            ),
            equalTo(tuple())
        )
    ),
    
    TestCase("zeroOrMoreWithSeparator fails fatally if first match fails fatally", fun() =>
        assertErrorParseWithError(
            rules.zeroOrMoreWithSeparator(fatalRule, rules.token("symbol", ",")),
            emptyList,
            Error("<expected>", "<actual>")
        )
    )
);

def failingRule fun(tokens: Sequence[Token]) =>
    Failure(Error("<expected>", "<actual>"), false);

def fatalRule fun(tokens: Sequence[Token]) =>
    Failure(Error("<expected>", "<actual>"), true);

def stringSource fun(string: String) =>
    createStringSource(string, "raw string");

def assertFailedParse fun[T] => (rule: Rule[T], input: List[Token]) => do {
    return assertParse[T](rule, input, isFailure);
};

def assertFailedParseWithError fun[T] => (rule: Rule[T], input: List[Token], error: Error) => do {
    return assertParse[T](rule, input, isFailureWithError(error));
};

def assertErrorParseWithError fun[T] => (rule: Rule[T], input: List[Token], error: Error) => do {
    return assertParse[T](rule, input, isErrorWithError(error));
};

def assertSuccessfulParse fun[T] => (rule: Rule[T], input: List[Token], value: T) => do {
    return assertParse[T](rule, input, isSuccess[T](value));
};

def assertParse fun[T] => (rule: Rule[T], input: List[Token], matcher: Matcher) => do {
    val result = rule(input.toSequence());
    return assertThat[T](result, matcher);
};
