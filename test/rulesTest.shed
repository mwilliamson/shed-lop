package lop;

import sequences;
import strings;
import lazySequences;

import hat.TestCase;
import duck.assertThat;
import duck.isList;
import duck.equalTo;
import duck.MatchResult;

import lop.rules;
import lop.results.Success;
import lop.Token;
import lop.StringSource;
import lop.strings.createStringSource;
import lop.testing.isSuccess;
import lop.testing.isFailure;
import lop.testing.isFailureWithError;
import lop.Error;

def source fun(value: String) => createStringSource(value, "raw string");

public val rulesTest = listOf[TestCase](
    TestCase("rules.token fails if sequence is empty", fun() =>
        assertFailedParseWithError[String](
            rules.token("identifier", "true"),
            emptyList,
            Error("token", "end of token sequence")
        )
    ),
    
    TestCase("rules.token fails if input token is of wrong type", fun() =>
        assertFailedParseWithError[String](
            rules.token("identifier", "true"),
            listOf(Token("keyword", "true", source("true"))),
            Error("identifier \"true\"", "keyword \"true\"")
        )
    ),
    
    TestCase("rules.token fails if input token has wrong value", fun() =>
        assertFailedParseWithError[String](
            rules.token("identifier", "true"),
            listOf(Token("identifier", "false", source("false"))),
            Error("identifier \"true\"", "identifier \"false\"")
        )
    ),
    
    TestCase("rules.token succeeds if type and value match", fun() =>
        assertSuccessfulParse[String](
            rules.token("identifier", "true"),
            listOf(Token("identifier", "true", source("true"))),
            "true"
        )
    ),
    
    TestCase("rules.tokenOfType fails if input token is of wrong type", fun() =>
        assertFailedParseWithError[String](
            rules.tokenOfType("identifier"),
            listOf(Token("keyword", "true", source("true"))),
            Error("identifier", "keyword \"true\"")
        )
    ),
    
    TestCase("rules.tokenOfType succeeds with value of token if token type matches", fun() =>
        assertSuccessfulParse[String](
            rules.tokenOfType("keyword"),
            listOf(Token("keyword", "true", source("true"))),
            "true"
        )
    )
);
    
def stringSource fun(string: String) =>
    createStringSource(string, "raw string");

def assertFailedParse fun[T] => (rule: Rule[T], input: List[Token]) => do {
    return assertParse[T](rule, input, isFailure);
};

def assertFailedParseWithError fun[T] => (rule: Rule[T], input: List[Token], error: Error) => do {
    return assertParse[T](rule, input, isFailureWithError(error));
};

def assertSuccessfulParse fun[T] => (rule: Rule[T], input: List[Token], value: T) => do {
    return assertParse[T](rule, input, isSuccess[T](value));
};

def assertParse fun[T] => (rule: Rule[T], input: List[Token], matcher: Matcher) => do {
    val result = rule(input.toSequence());
    return assertThat[T](result, matcher);
};
