module lop.testing;

members {
    isFailure,
    isFailureWithError,
    isErrorWithError,
    isSuccess
}

import sequences;
import lazySequences;
import strings;

import duck.MatchResult;
import duck;

import lop.token.Token;
import lop.results.Failure;

val isFailure = object {
    members {
        describeSelf,
        matches,
        describeMismatch,
        matchesWithDescription
    }
    
    def describeSelf fun() => "failure";
    
    def matches fun(result: ParseResult) =>
        matchesWithDescription(result).matches();
    
    def describeMismatch fun(result: ParseResult) =>
        matchesWithDescription(result).mismatchDescription();
        
    def matchesWithDescription fun(result: Result) =>
        if result.isSuccess() then
            MatchResult(false, "was not failure, was ".concat(represent(result)))
        else
            MatchResult(true, "");
};

def isFailureWithError fun(error: Error) => object {
    members {
        describeSelf,
        matches,
        describeMismatch,
        matchesWithDescription
    }
    
    def describeSelf fun() => "failure with error: ".concat(represent(error));
    
    def matches fun(result: ParseResult) =>
        matchesWithDescription(result).matches();
    
    def describeMismatch fun(result: ParseResult) =>
        matchesWithDescription(result).mismatchDescription();
        
    def matchesWithDescription fun(result: Result) =>
        if not(result.isFailure()) then
            MatchResult(false, "was not failure, was ".concat(represent(result)))
        else if not(result.error().equals(error)) then
            MatchResult(false, "error was ".concat(represent(result.error())))
        else
            MatchResult(true, "");
};

def isErrorWithError fun(error: Error) => duck.equalTo(Failure(error, true));

def isSuccess fun[T] => (matcher: Matcher[T]) => object {
    members {
        describeSelf,
        matches,
        describeMismatch,
        matchesWithDescription
    }
    
    def describeSelf fun() => "success with value ".concat(matcher.describeSelf());
    
    def matches fun(result: ParseResult) =>
        matchesWithDescription(result).matches();
    
    def describeMismatch fun(result: ParseResult) =>
        matchesWithDescription(result).mismatchDescription();
        
    def matchesWithDescription fun(result: Result) =>
        if result.isSuccess() then
            if not(matcher.matches(result.value())) then
                MatchResult(false, "value didn't match: ".concat(matcher.describeMismatch(result.value())))
            else if not(sequences.isNil(result.remaining())) then
                MatchResult(false, "entire input was not consumed, remaining was: ".concat(
                    strings.joinSequence(", ", lazySequences.map(represent, result.remaining()))
                ))
            else
                MatchResult(true, "")
        else
            MatchResult(false, "was not success, was ".concat(represent(result)))
}
