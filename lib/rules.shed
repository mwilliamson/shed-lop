package lop;

import lazySequenceables;
import sequenceables;
import lazySequences;
import sequences;

import lop.Token;
import lop.results.ParseResult;
import lop.results.Success;
import lop.results.Failure;
import lop.Error;

val results = object {
    members {
        success,
        failure
    }
    def success fun[T] => (value: T, remaining: StringSource) =>
        Success[T](value, remaining);
        
    def failure fun(expected: String, actual: String) =>
        Failure(Error(expected, actual));
};

public val rules = object {
    members {
        firstOf,
        tokenOfType,
        token,
        map,
        sequence,
        sequences rulesSequences
    }
    
    // TODO: should be type Rule[T] = Fun(Sequence[Token]) => ParseResult[T]
    def Rule class() => {}
    
    def firstOf fun(name: String, rules: List[Rule]) =>
        fun(tokens: Sequence[Token]) => do {
            val ruleResults = lazySequenceables.map[Rule, ParseResult](
                fun(rule: Rule) => rule(tokens),
                rules
            );
            val successes = lazySequenceables.filter[ParseResult](
                fun(result: ParseResult) => result.isSuccess(),
                ruleResults
            );
            return sequenceables.head[ParseResult](successes)
                .valueOrElse[ParseResult](fun() => withNextToken(tokens, fun(token: Token) =>
                    results.failure(name, describeToken(token))
                ));
        }
        
    def tokenOfType fun(name: String) =>
        fun(tokens: Sequence[Token]) =>
            withNextToken(tokens, fun(token: Token) =>
                if token.name().equals(name) then do {
                    // TODO: should have function to get an option of both head and tail at the same time
                    return results.success[String](token.value(), tokens.tail());
                } else
                    results.failure(name, describeToken(token))
            )
    
    def token fun(name: String, value: String) =>
        fun(tokens: Sequence[Token]) =>
            withNextToken(tokens, fun(token: Token) =>
                if and(token.name().equals(name), token.value().equals(value)) then
                    results.success[String](token.value(), tokens.tail())
                else
                    results.failure(describeTokenNameAndValue(name, value), describeToken(token))
            )
            
    def describeToken fun(token: Token) =>
        describeTokenNameAndValue(token.name(), token.value())
        
    def describeTokenNameAndValue fun(name: String, value: String) =>
        name.concat(" \"").concat(value).concat("\"");
        
    def withNextToken fun(tokens: Sequence[Token], func: Function[Token, ParseResult[String]]) =>
        sequences.head[Token](tokens)
            .map[Token, ParseResult[String]](func)
            .valueOrElse[ParseResult](fun() => results.failure("token", "end of token sequence"))
            
    def map fun[F, T] => (rule: Rule, func: Function[F, T]) =>
        fun(tokens: Sequence[Token]) =>
            rule(tokens).map[T](func)

    // type SequenceRule[T] = Rule[T] | Capture[T];

    def sequence fun() =>
        NoCaptureSequenceRule(sequences.nil);
        
    def NoCaptureSequenceRule class(rules: Sequence[SequenceRule[Any]]) => {
        members {
            next,
            capture,
            end
        }

        def next fun(rule: Rule[T]) => NoCaptureSequenceRule(sequences.cons[Rule](rule, rules));
        
        def capture fun(rule: Rule[T]) => OneCaptureSequenceRule(sequences.cons[Rule](Capture(rule), rules));

        def end fun() => 
            fun(tokens: Sequence[Tokens]) =>
                sequenceToRuleValues(sequences.reversed[Rule](rules))(tokens)
                    .map[Unit](fun() => ())
    }
    
    def OneCaptureSequenceRule class(rules: Sequence[SequenceRule[Any]]) => {
        members {
            next,
            capture,
            end
        }

        def next fun(rule: Rule[T]) =>
            OneCaptureSequenceRule(sequences.cons(rule, rules));
        
        def capture fun(rule: Rule[T]) =>
            MultipleCaptureSequenceRule(sequences.cons(Capture(rule), rules));

        def end fun() =>
            fun(tokens: Sequence[Tokens]) =>
                sequenceToRuleValues(sequences.reversed[Rule](rules))(tokens)
                    .map[Nothing](fun(values: Sequence) => values.head())
    }
    
    def MultipleCaptureSequenceRule class(rules: Sequence[SequenceRule[Any]]) => {
        members {
            next,
            capture,
            end
        }

        def next fun(rule: Rule[T]) =>
            MultipleCaptureSequenceRule(sequences.cons[Rule](rule, rules));
            
        def capture fun(rule: Rule[T]) =>
            MultipleCaptureSequenceRule(sequences.cons[Rule](rule, rules));

        def end fun() =>
            fun(tokens: Sequence[Tokens]) =>
                sequenceToRuleValues(sequences.reversed[Rule](rules))(tokens)
                    .map[Nothing](fun(values: Sequence) => tupleFromSequence(values))
    }
    
    def sequenceToRuleValues fun(rules: Sequence[SequenceRule[Any]]) =>
        fun(tokens: Sequence[Token]) =>
            sequences.head[Rule](rules).map[ParseResult](fun(rule: Rule) => do {
                val result = applySequenceRule(rule, tokens);
                return if result.isSuccess() then
                    sequenceToRuleValues(rules.tail())(result.remaining())
                        .map[Nothing](fun(values: Sequence) =>
                            match(rule,
                                matchClass(Capture, fun() => sequences.cons[Unit](result.value(), values)),
                                matchDefault(fun() => values)
                            )
                            
                        )
                else
                    result;
            })
            .valueOrElse[ParseResult](fun() => results.success[Unit](sequences.nil, tokens))
    
    def applySequenceRule fun(rule: SequenceRule[T], tokens: Sequence[Token]) =>
        match(rule,
            matchClass(Capture, fun(capture: Capture[T]) => capture.apply(tokens)),
            matchDefault(fun() => rule(tokens))
        );
    
    val rulesSequences = object {
        members {
            capture
        }
        
        def capture fun[T] => (rule: Rule[T]) => Capture(rule);
    };
        
    def Capture class(rule: Rule) => {
        members {
            apply rule
        }
    }
};
