module lop.results;

members {
    ParseResult,
    success,
    fatal,
    Failure,
    Success
}

import structs;

// TODO: should be an interface
def ParseResult class() => {}

def success fun[T] => (value: T, remaining: Sequence[Token]) =>
    Success(value, remaining)

def fatal fun(error: Error) =>
    Failure(error, true)

def Failure class(error: Error, isFatal: Boolean) => {
    members {
        map fun[R] => () => Failure(error, isFatal),
        bindWithRemaining fun[R] => (func: Function[Nothing, Sequence[Token], ParseResult[R]]) =>
            Failure(error, isFatal),
        isSuccess fun() => false,
        isFailure fun() => not(isFatal),
        isFatal fun() => isFatal,
        error fun() => error,
        struct fun() => structs.create(Failure, listOf(error, isFatal))
    }
}

def Success class[T] => (myValue: T, myRemaining: Sequence[Token]) => {
    members {
        value fun() => myValue,
        remaining fun() => myRemaining,
        map fun[R] => (func: Function[T, R]) =>
            Success[R](func(myValue), myRemaining),
        bindWithRemaining fun[R] => (func: Function[T, Sequence[Token], ParseResult[R]]) =>
            func(myValue, myRemaining),
        isSuccess fun() => true,
        isFailure fun() => false,
        isFatal fun() => false,
        struct fun() => structs.create(Success, listOf(myValue, myRemaining))
    }
}
